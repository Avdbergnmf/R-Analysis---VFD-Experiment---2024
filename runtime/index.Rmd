---
title: "VFD for gait variability"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: scroll # scroll # fill
runtime: shinyrmd
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(data.table)
library(RColorBrewer)
library(ggplot2)
library(ggpubr)
library(readxl)
library(rstatix)
library(plotrix)
library(car)
library(Rmisc)

# data manipulation
library(plyr)
library(dplyr)
library(purrr)

# plotting
library(tidyr)
library(devtools)
library(ggpattern) # To differentiate when printing in black and white

# LMER stuff
library(lme4)
library(DT)
#library(sjstats)
#library(lmerTest)
#library(emmeans)
#library(MuMIn)

# saving figures
library(svglite)

# File importing / reading
library(jsonlite) # for json files

# Reshaping data for questionnaires
#library(reshape2)

library(pwr)

# Filtering of foot signal for event detection
library(signal) # butterworth filter
library(zoo)  # For rolling statistics

# For correlation plots
library(ggstatsplot)
library(ggside)
```
### Main code
```{r data, include=FALSE, cache=TRUE}
################ PATH DEFINITIONS ################ 
dataFolder <- file.path(".", "data")
participants <- list.dirs(path = dataFolder, full.names = FALSE, recursive = FALSE)

# Column definitions
xOptions <- c("time", "pos_x", "pos_y", "pos_z")
#xOptionsVFD <- c("time", "magnitude", "offset_x", "offset_y", "offset_z", "final_pos_x", "final_pos_y", "final_pos_z", "rel_pos_x", "rel_pos_y", "rel_pos_z")
#xOptions <- c(xOptions, xOptionsVFD)

# Path definitions
questionnaireInfoFolder <- file.path(".", "questionnaires")
trackerPath <- file.path(file.path(dataFolder, participants[1]), "trackers")
trackers <- list.files(path = trackerPath, full.names = FALSE)
filenameDict <- list(
  "camera" = "camera_movement_T",
  "hip" = "hiptracker_movement_T",
  "leftfoot" = "leftfoottracker_movement_T",
  "lefthand" = "lefthandtracker_movement_T",
  "rightfoot" = "rightfoottracker_movement_T",
  "righthand" = "righthandtracker_movement_T",
  "steptargets" = "steptargetsmanager_targetsteps_T",
  "treadmillleft" = "treadmillleft_movement_T",
  "treadmillright" = "treadmillright_movement_T",
  "treadmillback" = "treadmillrightback_movement_T",
  "eye" = "eyetracking_EyeGaze_T",
  "leftdisturbance" = "leftfoot_disturbance_noise_T",
  "rightdisturbance" = "rightfoot_disturbance_noise_T"
)

################ Data retrieval / helper methods ################ 

# Data retrieval functions
get_p_dir <- function(pnum) {
  return(file.path(dataFolder, pnum))
}

get_p_resultsFile <- function(pnum) {
  return(file.path(get_p_dir(pnum), "trial_results.csv"))
}

get_p_results <- function(pnum, settingName, trialNumber) {
  # get the path to the settings file for the participant
  resultsFile <- get_p_resultsFile(pnum)
  results <- read.csv(resultsFile)
  
  # retrieve the value of the specific detail
  resultValue <- results[[settingName]][trialNumber]
  
  return(resultValue)
}

get_move_speed <- function(pnum) { # return move speed in m/s
  trialNum = 1 # should be the same for all trials
  return(get_p_results(pnum,"move_speed",trialNum) / 3.6)
}

get_p_detail <- function(pnum, detailName) {
  # get the path to the details file for the participant
  detailsFile <- file.path(get_p_dir(pnum), "participant_details.csv")
  
  # read the csv file into a data frame
  details <- read.csv(detailsFile)
  
  # retrieve the value of the specific detail
  detailValue <- details[[detailName]][1]
  
  return(detailValue)
}

# If true, the participant started with noise VFD enabled, otherwise without it enabled
started_with_noise <- function(pnum) {
  return(get_p_detail(pnum, "vfd_first"))
}

# get any type of data
get_t_data <- function(pnum, trackerType, trialNum) {
  # Validate trackerType
  if (!trackerType %in% names(filenameDict)) {
    stop("Invalid tracker type specified.")
  }
  
  filename <- paste0(filenameDict[[trackerType]], sprintf("%03d", trialNum), ".csv")
  filePath <- file.path(get_p_dir(pnum), "trackers", filename)
  
  # Use tryCatch for more robust error handling
  tryCatch(
    {
      data <- read.csv(filePath)
    },
    error = function(e) {
      message("Failed to read the file: ", e$message)
      return(NULL) # Or handle the error as appropriate for your context
    }
  )
  
  return(data)
}

get_q_file <- function(pnum, qType) { # qType = IMI / SSQ / VEQ
  return(file.path(get_p_dir(pnum), "Questionnaires", paste0("questionnaireID_", qType, "_ALL_answers.csv")))
}


################ Questionnaires ################

get_q_data <- function(pnum, qType) {
  # Get the path to the questionnaire file for the participant
  questionnaireFile <- get_q_file(pnum, qType)
  
  # Read the CSV file into a data frame
  questionnaire <- read.csv(questionnaireFile)
  
  # Extract the QuestionID and the two answer columns
  result <- questionnaire[, c("QuestionID", "Answer_Participant__condition_Base", "Answer_Participant__condition_Noise")]
  
  return(result)
}

get_question_info <- function(qType) { # qType = IMI / SSQ / VEQ
  qInfopath <- file.path(questionnaireInfoFolder, paste0(qType, ".csv"))
  # Read the CSV file into a data frame
  questionnaire <- read.csv(qInfopath)
  return(questionnaire)
}



### Questionnaire results calculation
compute_scores <- function(pnum, qType) {
  qdata <- get_q_data(pnum, qType)
  
  qinfo <- get_question_info(qType)
  combined <- merge(qdata, qinfo, by = "QuestionID")
  
  # Mirror the scores if needed
  combined$Answer_Participant__condition_Base <- ifelse(combined$mirror, 8 - combined$Answer_Participant__condition_Base, combined$Answer_Participant__condition_Base)
  combined$Answer_Participant__condition_Noise <- ifelse(combined$mirror, 8 - combined$Answer_Participant__condition_Noise, combined$Answer_Participant__condition_Noise)
  
  # Compute the scores for each category
  scoresBase <- tapply(combined$Answer_Participant__condition_Base, combined$category, mean, na.rm = TRUE)
  scoresNoise <- tapply(combined$Answer_Participant__condition_Noise, combined$category, mean, na.rm = TRUE)
  
  # Compute the total score for each condition
  scoresBase["total"] <- mean(scoresBase, na.rm = TRUE)
  scoresNoise["total"] <- mean(scoresNoise, na.rm = TRUE)
  
  return(list(base = scoresBase, noise = scoresNoise))
}

calculate_all_scores <- function(qType) {
  # Initialize empty data frames to hold the results
  dfBase <- data.frame()
  dfNoise <- data.frame()
  
  # Iterate over the participants
  for (participant in participants) {
    # Compute the scores
    scores <- compute_scores(participant, qType)
    
    # Transform the scores into a data frame with a single row and bind it with the participant ID
    baseRow <- cbind(participant = participant, as.data.frame(t(scores$base)))
    noiseRow <- cbind(participant = participant, as.data.frame(t(scores$noise)))
    
    # Add the scores to the data frames
    dfBase <- rbind(dfBase, baseRow)
    dfNoise <- rbind(dfNoise, noiseRow)
  }
  
  allScores <- list(base = dfBase, noise = dfNoise)
  
  # Reshape the data somewhat
  allScores$base$VFD <- FALSE
  allScores$noise$VFD <- TRUE
  
  combinedData <- rbind(allScores$noise, allScores$base)
  
  return(combinedData)
}

get_all_questionnaire_results <- function() {
  # Calculate all scores of all participants
  allQs <- c("IMI", "VEQ", "SSQ")
  # Initialize allQResults with the first questionnaire to establish a base for merging
  initialData <- calculate_all_scores(allQs[1])[, c("participant", "total", "VFD")]
  names(initialData)[names(initialData) == "total"] <- allQs[1]
  allQResults <- initialData
  
  # Loop through the remaining questionnaires
  for (currQ in allQs[-1]) {
    # Calculate scores for current questionnaire
    qData <- calculate_all_scores(currQ)[, c("participant", "total", "VFD")]
    names(qData)[names(qData) == "total"] <- currQ  # Rename 'total' to reflect questionnaire name
    
    # Merge with allQResults based on 'participant' and 'VFD'
    allQResults <- merge(allQResults, qData, by = c("participant", "VFD"), all = TRUE)
  }
  return(allQResults)
}

allQResults <- get_all_questionnaire_results() 

################ Data Manipulation ################ 

adjust_times <- function(dataset, minTime) { # make sure we start at t=0
  dataset$time <- dataset$time - minTime
  dataset <- subset(dataset, time <= 180)#dataset <- subset(dataset)
  return(dataset)
}

### TO DO, NOISEDATA MISSING
# Find the final positions by: foot position + noise values & add it to the DF
calc_final_pos <- function(footData, noiseData) {
  # Ensure both datasets are sorted by time to maintain order after joining
  footData <- footData %>% arrange(time)
  noiseData <- noiseData %>%
    select(time, offset_x, offset_y, offset_z) %>%
    arrange(time)
  
  # Join footData with noiseData by time
  footData <- footData %>%
    left_join(noiseData, by = "time") %>%
    rowwise() %>%
    mutate(
      magnitude = sqrt(offset_x^2 + offset_y^2 + offset_z^2),
      final_pos_x = pos_x + offset_x,
      final_pos_y = pos_y + offset_y,
      final_pos_z = pos_z + offset_z
    ) %>%
    ungroup()
  
  return(footData)
}

preprocess_data <- function(participant, trialNum){
  leftFoot = get_t_data(participant, "leftfoot", trialNum)
  rightFoot = get_t_data(participant, "rightfoot", trialNum)
  hip = get_t_data(participant, "hip", trialNum)
  targetData = get_t_data(participant, "steptargets", trialNum)
  leftDisturbance <- get_t_data(participant, "leftdisturbance", trialNum)
  rightDisturbance <- get_t_data(participant, "rightdisturbance", trialNum)
#rightFoot <- calc_final_pos(rightFoot, rightDisturbance)
#leftFoot <- calc_final_pos(leftFoot, leftDisturbance)
  minTime <- leftFoot$time[1] #get_p_results(participant,"start_time",trialNum)

  moveSpeed = get_move_speed(participant)
  leftFoot = adjust_times(leftFoot, minTime)
  leftFoot$actual_pos_z = leftFoot$pos_z + moveSpeed * leftFoot$time
  rightFoot = adjust_times(rightFoot, minTime)
  rightFoot$actual_pos_z = rightFoot$pos_z + moveSpeed * rightFoot$time
  
  return(list(
    leftFoot = leftFoot,
    rightFoot = rightFoot,
    leftDisturbance = leftDisturbance,
    rightDisturbance = rightDisturbance,
    hip = adjust_times(hip, minTime),
    targetData = adjust_times(targetData, minTime)
  ))
}

apply_padding_and_filter <- function(column, poly_order, frame_size, fs, cutoff_freq = 5) { 
  # Detect and remove outliers using a z-score method
  detect_outliers_filter <- function(column, threshold = 3) {
    # Calculate the z-scores
    z_scores <- (column - mean(column, na.rm = TRUE)) / sd(column, na.rm = TRUE)
    # Identify outliers
    outliers <- abs(z_scores) > threshold
    return(outliers)
  }
  
  # Detect outliers
  outliers <- detect_outliers_filter(column)
  
  # Replace outliers with NA
  column[outliers] <- NA
  
  # Interpolate the missing values (linear interpolation)
  column <- na.approx(column, rule = 2)
  
  # Calculate the number of points to pad (half the frame size generally works well)
  pad_width <- 20
  
  # Create mirrored padding
  padding_start <- rev(column[1:pad_width])
  padding_end <- rev(column[(length(column) - pad_width + 1):length(column)])
  
  # Pad the column
  padded_column <- c(padding_start, column, padding_end)
  
  # Apply Butterworth filter to the padded data
  b <- butter(poly_order, cutoff_freq / (fs / 2))  # 4th order Butterworth filter
  filtered_column <- filtfilt(b, padded_column)
  
  # Remove the padding
  filtered_column <- filtered_column[(pad_width + 1):(length(filtered_column) - pad_width)]
  
  return(filtered_column)
}

detect_foot_events_coordinates <- function(footData, hipData) {
  ####### FILTER
  # Apply a moving average filter to the relative foot position
  numeric_columns <- sapply(hipData, is.numeric)  # Identify numeric columns --> NOTE: actual_pos_z not filtered, but not needed here.
  
  # Apply the filter to all numeric columns
  poly_order <- 4  # Order of the polynomial (savgoy=3,butter=4)
  frame_size <- 5  # (for savgoy Must be odd)
  footData[numeric_columns] <- lapply(footData[numeric_columns], function(column) { apply_padding_and_filter(column, poly_order, frame_size, 90) } ) 
  hipData[numeric_columns] <- lapply(hipData[numeric_columns], function(column) { apply_padding_and_filter(column, poly_order, frame_size, 90) } )
  
  # Get subcomponents
  frontalFootPos <- footData$pos_z
  frontalHipPos <- hipData$pos_z
  #footHeight <- footData$pos_y ##### Could also do a height check, but looks good without it
  relFootPos <- frontalFootPos - frontalHipPos
  
  # Detect local extremes of relative foot pos - Based on https://c-motion.com/v3dwiki/index.php/Tutorial:_Gait_Events#Method_1._Coordinate_Based_Algorithm
  local_maxima <- which(diff(sign(diff(relFootPos))) == -2) + 1
  local_minima <- which(diff(sign(diff(relFootPos))) == 2) + 1
  
  if (local_minima[1] > local_maxima[1]) {
    local_maxima <- local_maxima[-1]
  }
  
  N_removed_min <- 0
  N_removed_max <- 0
  # alternation checking
  for (i in 1:(length(local_minima))) {
    if (i <= length(local_minima) && i <= length(local_maxima)) {
      while (local_maxima[i] < local_minima[i] && i <= length(local_minima) && i <= length(local_maxima)) {
        local_maxima <- local_maxima[-i] # remove the maxima, it is wrong
        N_removed_min <- N_removed_min + 1
      }
    }
      
    if (i+1 <= length(local_minima)  && i <= length(local_maxima)) {
      while (local_maxima[i] > local_minima[i+1] && i+1 <= length(local_minima)  && i <= length(local_maxima)) {
        local_minima <- local_minima[-(i+1)]
        N_removed_max <- N_removed_max + 1
      }
    }
  }
  
  # Make sure lengths match
  lMax <- length(local_maxima)
  lMin <- length(local_minima)
  if (lMax != lMin){
    if (lMax > lMin){print("Something REALLY WRONG... check detect_foot_events_coordinates()")}
    
    trimLength <- min(lMax, lMin)
    local_maxima <- local_maxima[1:trimLength]
    local_minima <- local_minima[1:trimLength]
  }
  
  # Some logging
  if (N_removed_max + N_removed_min > 0) {
    print(paste("removed",N_removed_max,"maxima, and",N_removed_min,"minima."))
  }
  if (length(local_maxima) !=length(local_minima)) {  
    print(paste("Length maxima:",length(local_maxima),"Length minima:",length(local_minima)))
  }
  
  # Extract positions and times
  heelStrikes <- data.frame(footData[local_maxima, ])
  toeOffs <- data.frame(footData[local_minima, ])
  print(paste("totalsteps: ",length(heelStrikes$time)))
  return(list(heelStrikes=heelStrikes,toeOffs=toeOffs))
}

find_foot_events <- function(participant, trialNum) {
  preprocessedData <- preprocess_data(participant, trialNum)
  
  leftFoot <- preprocessedData$leftFoot
  rightFoot <- preprocessedData$rightFoot
  hip <- preprocessedData$hip
  targetData <- preprocessedData$targetData
  
  # Detect toe-off and heelstrikes
  footEventsLeft <- detect_foot_events_coordinates(leftFoot, hip)
  footEventsRight <- detect_foot_events_coordinates(rightFoot, hip)
  
  # Add a 'foot' column to each event dataframe
  footEventsLeft$heelStrikes$foot <- 'Left'
  footEventsLeft$toeOffs$foot <- 'Left'
  footEventsRight$heelStrikes$foot <- 'Right'
  footEventsRight$toeOffs$foot <- 'Right'
  
  # Combine heel strikes and foot lifts from both feet
  combinedHeelStrikes <- rbind(footEventsLeft$heelStrikes, footEventsRight$heelStrikes)
  combinedToeOffs <- rbind(footEventsLeft$toeOffs, footEventsRight$toeOffs)
  
  # Order the events by time
  combinedHeelStrikes <- combinedHeelStrikes[order(combinedHeelStrikes$time), ]
  combinedToeOffs <- combinedToeOffs[order(combinedToeOffs$time), ]
  
  ensure_alternation <- function(data1, data2) {
    incorrect_seq <- which(diff(as.numeric(data1$foot == "Left")) == 0)
    
    if (length(incorrect_seq > 0)) {
      #print(data1[c(incorrect_seq,incorrect_seq+1),])
      data1 <- data1[-(incorrect_seq + 1),] # remove the second (later) value
      data2 <- data2[-(incorrect_seq + 1),] # remove the second (later) value
      print(paste("removed",length(incorrect_seq),"steps due to wrong alternation. At place(s):"))
      print(incorrect_seq)
      print("----------------------")
    }
    return(list(data1 = data1, data2 = data2))
  }
  
  # Apply alternation check on heelStrikes and remove index columns
  results <- ensure_alternation(combinedHeelStrikes, combinedToeOffs)
  combinedHeelStrikes <- results$data1
  combinedToeOffs     <- results$data2
  
  # Label step numbers. Assuming each heel strike represents a new step
  combinedHeelStrikes$step <- seq_len(nrow(combinedHeelStrikes))
  combinedToeOffs$step <- seq_len(nrow(combinedToeOffs))
  
  # Check if we stepped onto a target
  targetData <- targetData[order(targetData$time), ] # make sure we order by time
  combinedHeelStrikes$target <- FALSE
  for (i in 2:nrow(combinedHeelStrikes)) {
    prevStepTime <- combinedHeelStrikes$time[i-1]
    stepTime <- combinedHeelStrikes$time[i]
    
    # Find targets between the current heel strike and the next heel strike (or end of recording)
    targetsInTime <- targetData[targetData$time > prevStepTime & targetData$time <= stepTime, ]
    
    # Update the target_stepped_on flag if any targets were found
    if (nrow(targetsInTime) > 0) {
      combinedHeelStrikes$target[i] <- TRUE
    }
  }
  
  return(list(heelStrikes = combinedHeelStrikes, toeOffs = combinedToeOffs))
}

calculate_gait_parameters <- function(participant, trialNum) {
  gaitData <- find_foot_events(participant, trialNum)
  
  heelStrikesData <- gaitData$heelStrikes # should already be sorted based on time
  toeOffsData <- gaitData$toeOffs
  
  relHeelStrikesData <- gaitData$heelStrikes
  # Apply diff and padding to each numeric column
  relHeelStrikesData[] <- lapply(relHeelStrikesData, function(column) {
    if (is.numeric(column)) {
      # Calculate differences and pad with a leading zero
      c(0, diff(column))
    } else {
      column  # Return non-numeric columns unchanged
    }
  })
  
  # time-based
  stepTimes <- relHeelStrikesData$time # Calculate step times  >>> NOTE: The first heelstrike is only used as a starting point to the second
  swingTimes <- heelStrikesData$time - toeOffsData$time # Calculate swing times <<< L = N   (not N-1)
  stanceTimes <- stepTimes - swingTimes # Calculate stance times
  
  # position-based
  stepWidths <- relHeelStrikesData$pos_x # Calculate step width
  stepWidths <- ifelse(relHeelStrikesData$foot == "Left", stepWidths * -1, stepWidths) # Adjust sign based on which foot is stepping
  heelStrikeHeights <- 
  stepLengths <- relHeelStrikesData$actual_pos_z # Calculate step lengths
  
  speed <- stepLengths / stepTimes # Calculate speed
  
  # We ignore the steps onto and away from a target
  # and also add to the ignore list the outliers in the stepTimes and stepLengths (these are very obvious ways to remove the misdetected steps)
  targetSteps <- heelStrikesData$target
  targetSteps <- targetSteps | lead(heelStrikesData$target, default = FALSE) # add step before
  targetSteps <- targetSteps | lag(heelStrikesData$target, default = FALSE) | lag(heelStrikesData$target, 2, default = FALSE) # add steps after (until foot is placed back onto new position)
  heelStrikesData$targetIgnoreSteps <- targetSteps
  # Detect outliers
  heelStrikesData$outlierSteps <- detect_outliers(stepTimes, targetSteps) | detect_outliers(stepLengths, targetSteps)  | detect_outliers(gaitData$heelStrikes$pos_y, targetSteps) | detect_outliers(gaitData$toeOffs$pos_y, targetSteps)
  
  #stepsToIgnore <- outlierSteps
  # Make a list of all the gait parameters
  gaitParams <- list(
    stepTimes = stepTimes,
    stanceTimes = stanceTimes,
    swingTimes = swingTimes,
    #finalStepWidths = finalStepWidths,
    stepLengths = stepLengths,
    #finalStepLengths = finalStepLengths,
    stepWidths = stepWidths,
    speed = speed,
    heelStrikes = heelStrikesData, # We also add the heelstrikes info as it's interesting for plotting.
    toeOffs = toeOffsData,
    relHeelStrikes = relHeelStrikesData
  )
  
  return(gaitParams)
}

detect_outliers <- function(data, targetIgnoreSteps) {
  data_filtered <- data[!targetIgnoreSteps] # We don't use the target steps to calculate our interquartile ranges.
  
  Q1 <- quantile(data_filtered, 0.25)
  Q3 <- quantile(data_filtered, 0.75)
  IQR <- Q3 - Q1
  
  # Define the upper and lower bounds for outliers
  upper_bound <- Q3 + 1.5 * IQR
  lower_bound <- Q1 - 1.5 * IQR
  
  return(!(data >= lower_bound & data <= upper_bound))
}

################ GET RESULTS ################ 

allTrials <- c(1,2,3,4,5,6) # VFD conditions

calc_all_gait_params <- function(){
  # Initialize an empty data frame
  allGaitParams <- data.frame()
  # Loop over all participants
  for (participant in participants) {
    print(participant)
    # Loop over all trials
    for (trial in allTrials) {
      print(trial)
      # Calculate gait data and parameters
      gaitParams <- calculate_gait_parameters(participant, trial)
      
      # Convert the list of gait parameters to a data frame
      gaitParamsDf <- as.data.frame(gaitParams)
      
      # Add a column for the participant identifier
      gaitParamsDf$participant <- participant
      gaitParamsDf$trialNum <- trial
      gaitParamsDf$VFD <- get_p_results(participant,"noise_enabled",trial) == "True"
      gaitParamsDf$practice <- get_p_results(participant,"practice",trial) == "True"
      
      # Bind this participant's gait parameters to the overall data frame
      allGaitParams <- rbind(allGaitParams, gaitParamsDf)
    }
  }
  return(allGaitParams)
}

allGaitParams <- calc_all_gait_params()
#print(paste("totalsteps ALL: ",length(allGaitParams$heelStrikes.time)))
# used for summary table later
categories <- c("participant", "VFD", "trialNum")   # "trialNum", "heelStrikes.foot"
categoriesInputs <- append(categories, "None")
numericDataTypes <- sapply(allGaitParams, is.numeric)
logicalDataTypes <- sapply(allGaitParams, is.logical)
dataTypes <- names(numericDataTypes[numericDataTypes | logicalDataTypes])
dataTypes <- setdiff(dataTypes, categories)



### TARGET PARAMS



calc_all_target_params <- function(){
  # get just the target steps
  allTargetParams  <- data.frame() # allGaitParams[allGaitParams$heelStrikes.target == TRUE, ]
  
  # Loop over all participants
  print("---CALCULATING TARGET STEPS---")
  for (participant in participants) {
    print(participant)
    # Loop over all trials
    for (trial in allTrials) {
      print(trial)
      
      # get the target tracker results
      targetData <- get_t_data(participant, "steptargets", trial)
      targetData$rel_x <- targetData$foot_x - targetData$target_x
      targetData$rel_z <- targetData$foot_z - targetData$target_z
      
      # calculate total target distance
      targetData$targetDist <- sqrt(targetData$rel_x^2 + targetData$rel_z^2)
      
      # Convert the list of gait parameters to a data frame
      targetParamsDf <- as.data.frame(targetData)
      
      # Add a column for the participant identifier
      targetParamsDf$participant <- participant
      targetParamsDf$trialNum <- trial
      targetParamsDf$VFD <- get_p_results(participant,"noise_enabled",trial) == "True"
      targetParamsDf$practice <- get_p_results(participant,"practice",trial) == "True"
      
      # Bind this participant's gait parameters to the overall data frame
      allTargetParams <- rbind(allTargetParams, targetParamsDf)
    }
  }
  print("---FINISHED TARGET STEPS---")
  return(allTargetParams)
}

allTargetParams <- calc_all_target_params()
# used for summary table later
numericDataTypes <- sapply(allTargetParams, is.numeric)
logicalDataTypes <- sapply(allTargetParams, is.logical)
dataTypesTargets <- names(numericDataTypes[numericDataTypes | logicalDataTypes])
dataTypesTargets <- setdiff(dataTypesTargets, categories)

############################# SUMMARY TABLE ###################################

get_summ <- function(dataType, categories, filteredData) {
  filteredData %>%
    group_by(across(all_of(categories))) %>%
    summarise(
      mean = mean(.data[[dataType]], na.rm = TRUE),
      sd = sd(.data[[dataType]], na.rm = TRUE),
      cv = sd(.data[[dataType]], na.rm = TRUE) / mean(.data[[dataType]], na.rm = TRUE),
      .groups = "drop"
    )
}

# This table is huge (like 160 columns)
get_full_mu <- function(){
  # Assuming mu is a list of data frames, each corresponding to a dataType
  mu <- lapply(dataTypes, get_summ, categories = categories, filteredData = allGaitParams)
  mu <- setNames(mu, dataTypes)
  
  # Convert list to a single data frame
  mu_long <- bind_rows(mu, .id = "dataType") %>%
    pivot_longer(
      cols = -c(participant, VFD, trialNum, dataType), 
      names_to = "statistic", 
      values_to = "value"
    )
  
  # Create new column names and pivot to a wider format
  mu_wide <- mu_long %>%
    unite("new_col_name", dataType, statistic, sep = ".") %>%
    pivot_wider(
      names_from = new_col_name, 
      values_from = value
    )
  
  merged_results <- merge(allQResults, mu_wide, by = c("participant", "VFD"), all = TRUE)
  
  # Initialize new columns for deltaCv to 0.0 for each CV column
  cv_columns <- grep("\\.cv$", colnames(merged_results), value = TRUE)
  delta_cv_columns <- paste(cv_columns, "deltaCv", sep = ".")
  merged_results[delta_cv_columns] <- 0.0
  # Calculate avgNoVFD for each participant for non-practice VFD==FALSE trials
  noVFDTrials <- merged_results[merged_results$practice.mean == 0 & merged_results$VFD == FALSE, ]
  avgNoVFD <- noVFDTrials %>%
    group_by(participant) %>%
    summarise(across(all_of(cv_columns), \(x) mean(x, na.rm = TRUE)), .groups = 'drop')
  
  # Join avgNoVFD with the main data frame
  names(avgNoVFD)[-1] <- paste(sub("\\.cv$", "", names(avgNoVFD)[-1]), "avgNoVFD", sep = ".")
  mu_full <- merge(merged_results, avgNoVFD, by = c("participant"), all = TRUE)
  
  # Calculate deltaCv for each .cv column
  for (cv_col in cv_columns) {
    avg_col <- paste(sub("\\.cv$", "", cv_col), "avgNoVFD", sep = ".")  # Construct the avgNoVFD column name
    delta_col <- paste(cv_col, "deltaCv", sep = ".")  # Construct the deltaCv column name
    
    mu_full[[delta_col]] <- mu_full[[cv_col]] - mu_full[[avg_col]]
  }
  
  return(mu_full)
}


mu <- get_full_mu()

numericDataTypes <- sapply(mu, is.numeric)
logicalDataTypes <- sapply(mu, is.logical)
muDataTypes <- names(numericDataTypes[numericDataTypes | logicalDataTypes])
muDataTypes <- setdiff(muDataTypes, categories)



########################### PLOTTING FUNCTIONS ##############################

plot_steps <- function(filteredGaitParams, participant, trialNum, start=1, end=500, x_axis = "time", y_axis = "pos_z", doFilter = FALSE) { # start=first step to plot, end=last step to plot
  
    filteredGaitParams <- filteredGaitParams[filteredGaitParams$participant == participant & filteredGaitParams$trialNum == trialNum, ]
  
  preprocessedData <- preprocess_data(participant, trialNum) 
  rightData <- preprocessedData$rightFoot
  leftData <- preprocessedData$leftFoot
  
  # Filter out a subset of the steps if needed
  if (start > 1) {start <- start - 1} # make sure we get the step before
  steps <- start:end
  
  if (length(steps) > 1) {
    filteredGaitParams <- filteredGaitParams[filteredGaitParams$heelStrikes.step %in% steps,]
  }
  
  timeMin <- min(filteredGaitParams$heelStrikes.time)
  timeMax <- max(filteredGaitParams$heelStrikes.time)
  
  rightData <- rightData %>% dplyr::filter(time > timeMin & time < timeMax)
  leftData <- leftData %>% dplyr::filter(time > timeMin & time < timeMax)
  
  if (doFilter) {
      numeric_columns <- sapply(rightData, is.numeric)  # Identify numeric columns
      
      # Apply the filter to all numeric columns
      poly_order <- 4  # Order of the polynomial (savgoy=3,butter=4)
      frame_size <- 5  # (for savgoy Must be odd)
      rightData[numeric_columns] <- lapply(rightData[numeric_columns], function(column) { apply_padding_and_filter(column, poly_order, frame_size, 90) } ) 
      leftData[numeric_columns] <- lapply(leftData[numeric_columns], function(column) { apply_padding_and_filter(column, poly_order, frame_size, 90) } )
  }
  
  # Add a new column to both dataframes to identify the foot
  rightData$foot <- "Right"
  leftData$foot <- "Left"
  # Combine the dataframes
  both <- rbind(rightData, leftData)
  both <- both[order(both$time), ] # Order by time
  
  
  rParams <- filteredGaitParams[filteredGaitParams$heelStrikes.foot == "Right", ]
  lParams <- filteredGaitParams[filteredGaitParams$heelStrikes.foot == "Left", ]
  rTargets <- rParams[rParams$heelStrikes.target, ]
  lTargets <- lParams[lParams$heelStrikes.target, ]
  
  # Create the plot
  targetSize <- 5
  footEventSize <- 2
  p <- ggplot(both, aes(x = .data[[x_axis]], y = .data[[y_axis]], color = .data$foot)) +
    geom_path() +
    # toeOffs
    geom_point(data = rParams, aes(x = .data[[paste0("toeOffs.", x_axis)]], y = .data[[paste0("toeOffs.", y_axis)]]), shape = 24, color = "red", size = footEventSize) +
    geom_point(data = lParams, aes(x = .data[[paste0("toeOffs.", x_axis)]], y = .data[[paste0("toeOffs.", y_axis)]]), shape = 24, color = "blue", size = footEventSize) + # 12=empty square
    # heelstrikes
    geom_point(data = rParams, aes(x = .data[[paste0("heelStrikes.", x_axis)]], y = .data[[paste0("heelStrikes.", y_axis)]]), shape = 25, color = "red", size = footEventSize) + # 16=ball
    geom_point(data = lParams, aes(x = .data[[paste0("heelStrikes.", x_axis)]], y = .data[[paste0("heelStrikes.", y_axis)]]), shape = 25, color = "blue", size = footEventSize) +
    # targets
    geom_point(data = rTargets, aes(x = .data[[paste0("heelStrikes.", x_axis)]], y = .data[[paste0("heelStrikes.", y_axis)]]), shape = 10, color = "red", size = targetSize) +
    geom_point(data = lTargets, aes(x = .data[[paste0("heelStrikes.", x_axis)]], y = .data[[paste0("heelStrikes.", y_axis)]]), shape = 10, color = "blue", size = targetSize) + # 10=target
    scale_color_manual(values = c("Right" = "black", "Left" = "grey"))
  
  if (x_axis != "time" && y_axis != "time") {
    p <- p + coord_equal()
  }
  
  return(p)
}


add_lines <- function(p, footEvents, rightData, leftData, start, end, x_axis = "time", y_axis = "pos_z") { # start=first step to plot, end=last step to plot
  heelStrikes <- footEvents$heelStrikes
  
  # Filter out a subset of the steps if needed
  if (start > 1) {
    start <- start - 1
  } # make sure we get the step before
  steps <- start:end
  
  if (length(steps) > 1) {
    heelStrikes <- subset(heelStrikes, step %in% steps)
    # Filter out the steps we want to plot
    rHeelStrikes <- subset(heelStrikes, .data$foot == "Right")
    timeMin <- min(rHeelStrikes$time)
    timeMax <- max(rHeelStrikes$time)
    rightData <- subset(rightData, time > timeMin & time < timeMax)
    leftData <- subset(leftData, time > timeMin & time < timeMax)
  }
  
  # Add a new column to both dataframes to identify the foot
  rightData$foot <- "Right"
  leftData$foot <- "Left"
  
  # Create the plot
  p <- p + geom_path(data = rightData, aes(x = .data[[x_axis]], y = .data[[y_axis]]), color = "pink") +
    geom_path(data = leftData, aes(x = .data[[x_axis]], y = .data[[y_axis]]), color = "lightblue")
  if (x_axis != "time" && y_axis != "time") {
    p <- p + coord_equal()
  }
  return(p)
}

# For changing up the selection inputs - bit costly, but not really needed to optimize this
getOptions <- function(tracker){
  exampleData <- get_t_data(participants[1],tracker,1)
  numericTypes <- sapply(exampleData, is.numeric)
  numeric_cols <- names(exampleData[numericTypes]) # names(numericDataTypes[numericDataTypes | logicalDataTypes])
  return(numeric_cols)
}

plot_2d <- function(xtracker, ytracker, participant, trialNum, startTime, endTime, x_axis = "time", y_axis = "pos_z", plotlines = TRUE, plotpoints = FALSE) { 
  xData <- get_t_data(participant, xtracker, trialNum)
  yData <- get_t_data(participant, ytracker, trialNum)
  startTime <- get_p_results(participant,"start_time",trialNum)
  xData <- adjust_times(xData, startTime)
  yData <- adjust_times(yData, startTime)
  
  # Filter time subset if needed
  if (endTime > startTime && endTime != 0) {
    xData <- xData %>% dplyr::filter(time > startTime & time < endTime)
    yData <- yData %>% dplyr::filter(time > startTime & time < endTime)
  }    
  
  # Combine the dataframes
  both <- data.frame(
    x = xData[[x_axis]], 
    y = yData[[y_axis]]
  )
  
  p <- ggplot(xData, aes(.data[[x_axis]], .data[[y_axis]])) +  
    labs(title = "Time Series Plot", x = x_axis, y = y_axis)
  
  if (plotlines) { 
    p <- p + geom_path()
  }
  
  if (plotpoints) { 
    p <- p + geom_point()
  }
  
  if (x_axis != "time" && y_axis != "time") {
    p <- p + coord_equal()
  }
  
  return(p)
}

plot_questionnaire_data <- function(qType, participants, cols_to_include) {
  # Get the data
  data <- calculate_all_scores(qType)

  # Only keep the columns to include in the plot
  if (length(cols_to_include) == 0) {
    cols_to_include <- setdiff(colnames(data), c("participant", "VFD"))
  }
  data <- data[, c("participant", "VFD", cols_to_include), drop = FALSE]

  # Reshape the data to long format for ggplot
  data_long <- reshape2::melt(data, id.vars = c("participant", "VFD"))

  # Create the plot for each column to include
  p <- ggpaired(
    data = data_long,
    x = "VFD",
    y = "value",
    id = "participant",
    color = "VFD",
    line.color = "gray",
    line.size = 0.4
  ) +
    facet_wrap(~variable, scales = "free", ncol = length(cols_to_include)) +
    labs(x = "VFD", y = "Score") +
    ggtitle(paste0("Boxplots of ", qType, " Scores")) +
    theme(plot.title = element_text(hjust = 0.5)) +
    ylim(0, 7) # Set y-axis limits

  return(p)
}

plot_variability_data <- function(mu_dyn, datatype, metric) {
  # Get the data
  data <- mu_dyn[[datatype]]
  data <- data[, c("participant", "VFD","trialNum", metric), drop = FALSE]
  #data$trialNum <- as.factor(data$trialNum)
  # Reshape the data to long format for ggplot
  data_long <- reshape2::melt(data, id.vars = c("participant", "VFD", "trialNum"))
  
  #data_long$trialNum <- factor(data_long$trialNum)
  num_trials = 6
  colors <- brewer.pal(6, "Dark2")  # Adjust palette as needed
  color_map <- setNames(colors, unique(data_long$trialNum))
  data_long$color <- color_map[as.character(data_long$trialNum)]

  # Create the plot for each column to include
  p <- ggpaired(
    data = data_long,
    x = "VFD",
    y = "value",
    id = "participant",
    color = "trialNum", # VFD, trialNum
    line.color = "white",
    point.color= "color",
    line.size = 0.0
  ) +
    # facet_wrap(~ variable, scales = "free", ncol = length(cols_to_include)) +
    labs(x = "VFD", y = metric) +
    ggtitle(paste0("Boxplots of ", datatype, " (", metric, ") Scores")) +
    theme(plot.title = element_text(hjust = 0.5)) +
    coord_cartesian(ylim = range(data_long$value, na.rm = TRUE))+ # Set y limits to the range of y values in data
    scale_color_identity(name = "Trial Number", labels = names(color_map), aesthetics = "point.color")  # Tell ggplot2 to use the colors as they are
    #scale_color_manual(values = color_map, )

  return(p)
}


make_pie_chart <- function(data){
  #data <- filteredParams()
  targetIgnoreSteps <- length(data[data$heelStrikes.targetIgnoreSteps==TRUE & data$heelStrikes.outlierSteps == FALSE,]$VFD)
  outlierSteps <- length(data[data$heelStrikes.targetIgnoreSteps==FALSE & data$heelStrikes.outlierSteps == TRUE,]$VFD)
  bothSteps <- length(data[data$heelStrikes.targetIgnoreSteps==TRUE & data$heelStrikes.outlierSteps == TRUE,]$VFD)
  included <- length(data[data$heelStrikes.targetIgnoreSteps==FALSE & data$heelStrikes.outlierSteps == FALSE,]$VFD) # non filtered out
  total_steps <- length(data$VFD)

  # Create a data frame for ggplot
  df_filtered <- data.frame(
    StepType = factor(c("Both", "Target Ignore", "Outlier", "Included")),
    TotalCount = c(bothSteps, targetIgnoreSteps, outlierSteps, included)
  )
  
  ### LABELING LOOKS HELLA OFF, HARDCODE FIX FOR NOW
  # Order the data frame by StepType for consistent plotting
  #df_filtered <- df_filtered[order(df_filtered$StepType, decreasing = TRUE), ]

  # Calculate label positions for the pie chart
  #df_filtered$midpoint <- cumsum(df_filtered$TotalCount) - df_filtered$TotalCount / 2
  #df_filtered$label_pos <- df_filtered$midpoint / sum(df_filtered$TotalCount) * 2 * pi
  
  # Calculate label positions for the pie chart
  df_filtered$label_pos <- cumsum(df_filtered$TotalCount) - df_filtered$TotalCount/2
  
  # Generate the pie chart
  p <- ggplot(df_filtered, aes(x = "", y = TotalCount, fill = StepType)) +
    geom_bar(stat = "identity", width = 1) +
    coord_polar(theta = "y", start = 0) +
    theme_void() +
    scale_fill_brewer(palette = "Pastel1") +
    geom_text(aes(label = TotalCount, y = label_pos), color = "black") +
    ggtitle(paste("Total steps =", total_steps))
  
  return(p)
}

```

Sidebar {.sidebar}
=====================================

#### Filtering
```{r}
selectizeInput("filterParticipants", "Participants", choices = participants, selected = participants, multiple = TRUE)
selectizeInput("filterVFD", "VFD", choices = c(TRUE, FALSE), selected = c(TRUE, FALSE), multiple = TRUE)
selectizeInput("filterTrials", "Trials", choices = c(1,2,3,4,5,6), selected = c(1,2,3,4,5,6), multiple = TRUE)
selectizeInput("filterTargets", "Target Steps", choices = c(TRUE, FALSE), selected = c(FALSE), multiple = TRUE)
selectizeInput("filterOutliers", "Outliers", choices = c(TRUE, FALSE), selected = c(FALSE), multiple = TRUE) # INCLUDE outliers (TRUE), INCLUDE non-outliers (FALSE)
selectizeInput("filterPractice", "Familiarization", choices = c(TRUE, FALSE), selected = c(FALSE), multiple = TRUE)
```

#### Figure Options
```{r}
numericInput("plotheight", "Plot Height",
  min = 50, max = Inf, value = 500, step = 50)
```

Feet trajectories {data-orientation=columns}
=====================================


### Plot Options
```{r}
trialNumbers = c(1,2,3,4,5,6)
checkboxInput("filter", "Show filtered data",
  value = FALSE)
selectizeInput("participant", "participant",
  choices = participants, selected = participants[1], multiple = FALSE)
selectizeInput("trialNum", "Trial Number",
  choices = trialNumbers, selected = trialNumbers[2], multiple = FALSE) # set to trial 2 so that if practice is filtered out, it still plots


selectizeInput("xplot", "xplot",
  choices = xOptions, selected = xOptions[2], multiple = FALSE)
selectizeInput("yplot", "yplot",
  choices = xOptions, selected = xOptions[3], multiple = FALSE)

numericInput("start", "start at step nr",
  min = 0, max = 500, value = 0, step = 1)
numericInput("end", "end at step nr",
  min = 0, max = 500, value = 0, step = 1)
```


Column
--------------------------------------------
### Feet trajectories {data-height=500}

```{r}
plotOutput("FeetTraj")
```

```{r, context="server"}
# Dynamically filter gaitParams and mu table calc
filteredParams <- reactive({
  included <- allGaitParams[["participant"]] %in% input$filterParticipants
  included <- included & allGaitParams[["VFD"]] %in% input$filterVFD
  included <- included & allGaitParams[["trialNum"]] %in% input$filterTrials
  included <- included & allGaitParams[["heelStrikes.targetIgnoreSteps"]] %in% input$filterTargets
  included <- included & allGaitParams[["heelStrikes.outlierSteps"]] %in% input$filterOutliers
  included <- included & allGaitParams[["practice"]] %in% input$filterPractice
  
  return(allGaitParams[included, ])
})

filteredTargetParams <- reactive({
  included <- allTargetParams[["participant"]] %in% input$filterParticipants
  included <- included & allTargetParams[["VFD"]] %in% input$filterVFD
  included <- included & allTargetParams[["trialNum"]] %in% input$filterTrials
  included <- included & allTargetParams[["practice"]] %in% input$filterPractice
  
  return(allTargetParams[included, ])
})

get_mu_dyn <- reactive({
  mu_dyn <- lapply(dataTypes, get_summ, categories = categories, filteredData = filteredParams())
  mu_dyn <- setNames(mu_dyn, dataTypes)
  
  return(mu_dyn)
})

get_mu_dyn_long <- reactive({
  mu_dyn <- get_mu_dyn()
  
  # Convert list to a single data frame
  mu_long <- bind_rows(mu_dyn, .id = "dataType") %>%
    pivot_longer(
      cols = -c(participant, VFD, trialNum, dataType), 
      names_to = "statistic", 
      values_to = "value"
    )

  # Create new column names and pivot to a wider format
  mu_wide <- mu_long %>%
    unite("new_col_name", dataType, statistic, sep = ".") %>%
    pivot_wider(
      names_from = new_col_name, 
      values_from = value
    )

  merged_results <- merge(allQResults, mu_wide, by = c("participant", "VFD"), all = TRUE)
  merged_results <- merged_results[!(merged_results$trialNum %in% c(1,4)),]
  
  ### Extra stuff to get relative CV from mean of NoVFD condition compared to VFD trials
  
  # Initialize new columns for deltaCv to 0.0 for each CV column
  cv_columns <- grep("\\.cv$", colnames(merged_results), value = TRUE)
  delta_cv_columns <- paste(cv_columns, "deltaCv", sep = ".")
  merged_results[delta_cv_columns] <- 0.0
  
  # Calculate avgNoVFD for each participant for non-practice VFD==FALSE trials
  noVFDTrials <- merged_results[merged_results$practice.mean == 0 & merged_results$VFD == FALSE, ]
  avgNoVFD <- noVFDTrials %>%
    group_by(participant) %>%
    summarise(across(all_of(cv_columns), \(x) mean(x, na.rm = TRUE)), .groups = 'drop')
  
  # Join avgNoVFD with the main data frame
  names(avgNoVFD)[-1] <- paste(sub("\\.cv$", "", names(avgNoVFD)[-1]), "avgNoVFD", sep = ".")
  mu_full <- merge(merged_results, avgNoVFD, by = c("participant"), all = TRUE)
  
  # Calculate deltaCv for each .cv column
  for (cv_col in cv_columns) {
    avg_col <- paste(sub("\\.cv$", "", cv_col), "avgNoVFD", sep = ".")  # Construct the avgNoVFD column name
    delta_col <- paste(cv_col, "deltaCv", sep = ".")  # Construct the deltaCv column name
    
    mu_full[[delta_col]] <- mu_full[[cv_col]] - mu_full[[avg_col]]
    mu_full[mu_full$VFD == FALSE, delta_col] <- NA # these values make no sense so we remove them from the dataset
  }
  #mu_full$trialNum <- as.factor(mu_full$trialNum)
  return(mu_full)
})

#reactive(), reactiveVal(), reactiveData()
output$FeetTraj <- renderPlot(
  {
    plot_steps(filteredParams(), input$participant, as.numeric(input$trialNum), input$start, input$end, input$xplot, input$yplot, input$filter)
  },
  height = reactive(input$plotheight)
)
```

# Removed Steps


### Plot Options
```{r}
checkboxInput("useFiltered", "Filter data",
  value = FALSE
)
```

Column
--------------------------------------------


### Removed Steps {data-height=500}


```{r}
plotOutput("pie")
```

```{r, context="server"}
output$pie <- renderPlot(
  {
    if (input$useFiltered) {data <- filteredParams() }
    else (data <- allGaitParams)
    
    return(make_pie_chart(data))
  },
  height = reactive(input$plotheight)
)

```

2D Plot {data-orientation=columns}
=====================================


### Plot Options
```{r}
trackers <- names(filenameDict)
xOptions2D <- colnames(get_t_data(participants[1],"leftfoot",1)) # options for pos rot trackers

checkboxInput("plotlines", "plot lines",value=TRUE)
checkboxInput("plotpoints", "plot points",value=FALSE)

selectizeInput("xtracker", "Data to plot",
  choices = trackers, selected = trackers[2], multiple = FALSE)
#selectizeInput("ytracker", "Y Data to plot",
#  choices = trackers, selected = trackers[2], multiple = FALSE)

selectizeInput("participant2d", "participant",
  choices = participants, selected = participants[1], multiple = FALSE)
selectizeInput("trialNum2d", "Trial Number",
  choices = trialNumbers, selected = trialNumbers[1], multiple = FALSE)


selectizeInput("xplot2d", "xplot",
  choices = xOptions2D, selected = xOptions2D[2], multiple = FALSE)
selectizeInput("yplot2d", "yplot",
  choices = xOptions2D, selected = xOptions2D[3], multiple = FALSE)

numericInput("startTime", "start time (s)",
  min = 0, max = 500, value = 0, step = 1)
numericInput("endTime", "end time (s)",
  min = 0, max = 500, value = 0, step = 1)
```


Column
--------------------------------------------
### 2D plot {data-height=1500}

```{r}
plotOutput("TwoD")
```

```{r, context="server"}

observeEvent(input$xtracker, {
  choices <- getOptions(input$xtracker)
  updateSelectInput(session= getDefaultReactiveDomain(),"xplot2d", choices = choices, selected = choices[1])
  updateSelectInput(session= getDefaultReactiveDomain(),"yplot2d", choices = choices, selected = choices[1])
})

output$TwoD <- renderPlot(
  { # note, 2 times xtracker, not distinguishing between x and y for now.
    plot_2d(input$xtracker, input$xtracker, input$participant2d, as.numeric(input$trialNum2d), input$startTime, input$endTime, input$xplot2d, input$yplot2d, input$plotlines, input$plotpoints)
  },
  height = reactive(input$plotheight)
)
```


# Target Steps

### Options
```{r,echo=FALSE}
selectizeInput("targetPlotPlot", "Plot",
  choices = dataTypesTargets, selected = dataTypesTargets[2], multiple = FALSE
)
selectizeInput("targetPlotGroup", "Group by",
  choices = categoriesInputs, selected = categoriesInputs[1], multiple = FALSE
)
selectizeInput("targetPlotPosition", "Bar positions",
  choices = c("stack", "identity", "dodge"), selected = "identity", multiple = FALSE
)
selectizeInput("targetPlotSplit", "Split by",
  choices = categoriesInputs, selected = "None", multiple = FALSE
)

numericInput("targetPlotBin", "Bin width",
  min = 0.001, max = 0.5, value = 0.01, step = 0.01
)
```

Column
--------------------------------------------

### Histograms  {data-height=1000}
```{r}
plotOutput("histTargets")
```

### Target Steps  {data-height=1000}
```{r}
plotOutput("targets")
```


```{r, context="server"}

circleFun <- function(center = c(0,0),r = 1, npoints = 100){
    tt <- seq(0,2*pi,length.out = npoints)
    xx <- center[1] + r * cos(tt)
    yy <- center[2] + r * sin(tt)
    return(data.frame(x = xx, y = yy))
}

output$targets <- renderPlot({
  circle = circleFun(c(0,0),0.3,100)
  dt = filteredTargetParams()
  axesLims <- 0.5
  p <- ggplot() +
    geom_path(data = circle, aes(x = x, y = y), color = "black") +
    geom_point(data = dt, aes(x = rel_x, y = rel_z,col=VFD), fill=rgb(0,0,0,0.2),shape = 21,size=10) + 
    xlim(-axesLims,axesLims) +
    ylim(-axesLims,axesLims)
  
  p <- p + coord_equal() +
    labs(title = "Center Foot Relative to Target Center", x = "x", y = "z")
  
  return(p)
}, height = reactive(input$plotheight))

makeTargetHistogramPlot <- reactive({
  aes <- aes_string(x = input$targetPlotPlot)
  a <- 1
  fill <- "grey"
  if (input$targetPlotGroup != "None") {
    fill <- "white"
    aes <- modifyList(aes, aes_string(col = input$targetPlotGroup))
    if (input$targetPlotPosition == "identity") {
      a <- 1 / 2
    }
  }

  p <- ggplot(filteredTargetParams(), aes) +
    geom_histogram(binwidth = input$targetPlotBin, fill = fill, alpha = a, position = input$targetPlotPosition)

  if (input$targetPlotSplit != "None") {
    p <- p + facet_grid(sym(input$targetPlotSplit))
  }

  return(p)
})

output$histTargets <- renderPlot(
  {
    makeTargetHistogramPlot()
  },
  height = reactive(plotHeight())
)
```

# Histograms 


### Options

```{r}
selectizeInput("plot", "Plot",
  choices = dataTypes, selected = dataTypes[1], multiple = FALSE
)
selectizeInput("group", "Group by",
  choices = categoriesInputs, selected = categoriesInputs[1], multiple = FALSE
)
selectizeInput("position", "Bar positions",
  choices = c("stack", "identity", "dodge"), selected = "identity", multiple = FALSE
)
selectizeInput("split", "Split by",
  choices = categoriesInputs, selected = "None", multiple = FALSE
)
checkboxInput("means", "Show means",
  value = TRUE
)
numericInput("bin", "Bin width",
  min = 0.001, max = 0.5, value = 0.01, step = 0.01
)
```

Column
--------------------------------------------

### Histograms  {data-height=1500}
```{r}
plotOutput("hist")
```

```{r, context="server"}
plotCount <- reactive({
  colName <- as.character(input$split)
  return(uniqueN(allGaitParams[[colName]]))
})

plotHeight <- reactive(
  if (input$split == "None") {
    return(input$plotheight)
  } else {
    return(input$plotheight * plotCount())
  }
)

makeHistogramPlot <- reactive({
  aes <- aes_string(x = input$plot)
  a <- 1
  fill <- "grey"
  if (input$group != "None") {
    fill <- "white"
    aes <- modifyList(aes, aes_string(col = input$group))
    if (input$position == "identity") {
      a <- 1 / 2
    }
  }

  p <- ggplot(filteredParams(), aes) +
    geom_histogram(binwidth = input$bin, fill = fill, alpha = a, position = input$position)
  
  mu_dyn <- get_mu_dyn()
  
  if (input$means && input$split != "None") {
    p <- p + geom_vline(mu_dyn[[input$plot]], mapping = aes_string(xintercept = "mean", col = input$split), linetype = "dashed")
  }
  if (input$means && input$split == "None" && input$group != "None") {
    p <- p + geom_vline(mu_dyn[[input$plot]], mapping = aes_string(xintercept = "mean", col = input$group), linetype = "dashed")
  }

  if (input$split != "None") {
    p <- p + facet_grid(sym(input$split))
  }

  return(p)
})

output$hist <- renderPlot(
  {
    makeHistogramPlot()
  },
  height = reactive(plotHeight())
)
```

# Scatterplots

### Options
```{r,echo=FALSE}
selectizeInput("xscatter", "xscatter",
  choices = dataTypes, selected = dataTypes[1], multiple = FALSE
)
selectizeInput("yscatter", "yscatter",
  choices = dataTypes, selected = dataTypes[1], multiple = FALSE
)

selectizeInput("groupScatter", "Group by",
  choices = categoriesInputs, selected = categoriesInputs[1], multiple = FALSE
)
```

Column
--------------------------------------------

### Scatterplot  {data-height=1500}

```{r}
plotOutput("scatter")
```

```{r, context="server"}
make_scatter_plot <- reactive({
  if (input$groupScatter == "None") {
    aes <- aes_string(x = input$xscatter, y = input$yscatter)
  }
  else{
    aes <- aes_string(x = input$xscatter, y = input$yscatter, col = input$groupScatter)
  }

  p <- ggplot(filteredParams(), aes) +
    geom_point(alpha = 0.5) # Set the alpha to make overlapping points more visible
  
  both_contain_pos <- grepl("pos", input$xscatter, ignore.case = TRUE) && grepl("pos", input$yscatter, ignore.case = TRUE)
  if (both_contain_pos) {
    p <- p + coord_equal()
  }
  
  return(p)
})

output$scatter <- renderPlot({
  make_scatter_plot()
}, height = reactive(input$plotheight))
```


# Scatterplots TrialData

### Options
```{r,echo=FALSE}
removePattern <- "heelStrikes\\.|toeOffs\\."
muDataTypesFilt <- grep(removePattern, muDataTypes, value = TRUE, invert = TRUE)

selectizeInput("muxscatter", "xscatter",
  choices = muDataTypesFilt, selected = muDataTypesFilt[1], multiple = FALSE
)
selectizeInput("muyscatter", "yscatter",
  choices = muDataTypesFilt, selected = muDataTypesFilt[1], multiple = FALSE
)

selectizeInput("groupScatter", "Group by",
  choices = categoriesInputs, selected = categoriesInputs[1], multiple = FALSE
)
```

Column
--------------------------------------------

### Scatterplot TrialData {data-height=1500}

```{r}
plotOutput("scatter_mu")
```

```{r, context="server"}
make_scatter_plot_mu <- reactive({
  if (input$groupScatter == "None") {
    aes <- aes_string(x = input$muxscatter, y = input$muyscatter)
  }
  else{
    aes <- aes_string(x = input$muxscatter, y = input$muyscatter, col = input$groupScatter)
  }

  p <- ggplot(get_mu_dyn_long(), aes) +
    geom_point(alpha = 0.5) # Set the alpha to make overlapping points more visible

  return(p)
})

output$scatter_mu <- renderPlot({
  make_scatter_plot_mu()
}, height = reactive(input$plotheight))
```

# Questionnaires 


### Options

```{r}
questionnaireList <- c("VEQ", "SSQ", "IMI")
selectizeInput("plotQ", "Plot Questionnaire", choices = questionnaireList, selected = questionnaireList[1], multiple = FALSE)
```

Column
--------------------------------------------

### Questionnaire Boxplots  {data-height=1500}
```{r}
plotOutput("q")
```

```{r, context="server"}
output$q <- renderPlot({
  plot_questionnaire_data(input$plotQ, participants, c())
}, height = reactive(input$plotheight))
```

# Variability 


### Options

```{r}
questionnaireList <- c("VEQ", "SSQ", "IMI")
varDatatypes <- c("stepLengths", "stepWidths")
varMetrics <- c("cv", "mean", "sd")
selectizeInput("plotVar", "Variability of", choices = varDatatypes, selected = varDatatypes[1], multiple = FALSE)
selectizeInput("plotMetric", "Metric", choices = varMetrics, selected = varMetrics[1], multiple = FALSE)
```

Column
--------------------------------------------

### Step Variability Plot  {data-height=1500}
```{r}
plotOutput("var")
```

```{r, context="server"}
output$var <- renderPlot({
  plot_variability_data(get_mu_dyn(), input$plotVar, input$plotMetric)
}, height = reactive(input$plotheight))
```









# Statistics {data-icon="fa-chart-bar"}

### Options

```{r}
muVars <- colnames(mu)
defaultIndepVars <- c("VFD", "trialNum")
defaultDepVar <- "stepWidths.cv"
selectizeInput("depVar", "Dependent variable", choices = muVars, selected = defaultDepVar, multiple = FALSE)
selectizeInput("indepVars", "Independent variables", choices = muVars, selected = defaultIndepVars, multiple = TRUE)
checkboxInput("interaction", "Include Interaction (VFD*trialNum)", value = TRUE)
```

Column
--------------------------------------------

### Statistics Results  {data-height=500}
```{r}
#plotOutput("qq") ## QQ plot to check if we can use LMM?
verbatimTextOutput("lmm_text")
```
### Tables

#### Fixed effects {data-height=500}
```{r}
tableOutput("fixed_effects_table")
```

#### Random effects {data-height=500}
```{r}
tableOutput("random_effects_table")
```

```{r, context="server"}
get_lmer = reactive({
  dt <- get_mu_dyn_long()
  
  # Construct the formula dynamically using input$depVar and input$indepVars
  dep_var <- input$depVar
  indep_vars <- paste(input$indepVars, collapse = " + ")
  
  # Add interaction term if selected
  if (input$interaction) {
    formula_text <- paste(dep_var, "~", indep_vars, "+ (1 | participant) + VFD*trialNum")
  } else {
    formula_text <- paste(dep_var, "~", indep_vars, "+ (1 | participant)")
  }
  
  formula <- as.formula(formula_text)
  return(lmer(formula, data=dt, REML=FALSE))
})

output$lmm_text <- renderPrint({
  lmm <- get_lmer()
  results <- summary(lmm)
  
  # Summarize the model
  cat("\nLMM:\n")
  print(lmm)
  cat("\nRESULTS:\n")
  print(results)
})

output$fixed_effects_table <- renderTable({
  lmm <- get_lmer()
  results <- summary(lmm)
  fixed_effects <- results$coefficients
  
  # Convert to a data frame for rendering and include row names
  fixed_effects_df <- as.data.frame(fixed_effects)
  fixed_effects_df <- cbind(Effect = rownames(fixed_effects_df), fixed_effects_df)
  rownames(fixed_effects_df) <- NULL
  fixed_effects_df
}, rownames = TRUE)

output$random_effects_table <- renderTable({
  lmm <- get_lmer()
  random_effects <- as.data.frame(VarCorr(lmm))
  
  # Clean up the random effects table
  random_effects_df <- cbind(Effect = rownames(random_effects), random_effects)
  rownames(random_effects_df) <- NULL
  
  # Select only relevant columns
  random_effects_df <- random_effects_df[, c("Effect", "grp", "vcov", "sdcor")]
  
  # Optionally rename columns for clarity
  colnames(random_effects_df) <- c("Effect", "Group", "Variance", "Standard Deviation")
  
  random_effects_df
}, rownames = TRUE)

output$qq <- renderPlot({
  lmm <- get_lmer()
  p <- qqnorm(resid(lmm))
  return(p)
})
```




# Correlations {data-icon="fa-chart-line"}

### Options

```{r}
selectInput("par", "Parametric data", 
            choices = c("parametric", "nonparametric", "bayes", "robust"), 
            selected = "parametric", multiple = FALSE)
```

Column
--------------------------------------------

### Correlation Plots  {data-height=500}

#### Density Plot - VEQ
```{r}
plotOutput("corrVEQ")
```

#### Density Plot - IMI
```{r}
plotOutput("corrIMI")
```

### Correlation Results  {data-height=500}
```{r}
verbatimTextOutput("correlation_text")
```

### Scatter Plots with Correlation {data-height=1000}

#### Scatter Plot
```{r}
plotOutput("scatter")
```

```{r, context="server"}
output$corrVEQ <- renderPlot({
  dt <- get_mu_dyn_long()
  ggplot(dt, aes(VEQ)) + geom_density(fill = "gray") # [dt$VFD == FALSE, ]
}, height = reactive(input$plotheight))

output$correlation_text <- renderPrint({
  dt <- get_mu_dyn_long()
  
  # Check normality of averages
  print(shapiro.test(dt$grp.mean))
  print(shapiro.test(dt$embodiment_Body))
  print(shapiro.test(muFQ_$grp.mean))
  print(shapiro.test(muFQ_$embodiment_Feet))
  
  correlationA <- cor(muAQ_$embodiment_Body, muAQ_$grp.mean, method = 'pearson')
  correlationF <- cor(muFQ_$embodiment_Feet, muFQ_$grp.mean, method = 'pearson')
  print(paste("Embodiment Body vs Distance:", correlationA))
  print(paste("Embodiment Feet vs Distance:", correlationF))
})

output$scatter <- renderPlot({
  dt <- get_mu_dyn_long()
  ggscatterstats(data = dt, x = VEQ, y = stepWidths.cv, type = input$par)
}, height = reactive(input$plotheight))

```