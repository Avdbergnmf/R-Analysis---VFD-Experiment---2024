### Options

```{r}
defaultIndepVars <- c("VFD")
defaultDepVar <- "stepWidths.sd"
selectizeInput("depVar", "Dependent variable", choices = muVars, selected = defaultDepVar, multiple = FALSE)
selectizeInput("indepInterVars", "* Independent variables", choices = muVars, selected = defaultIndepVars, multiple = TRUE)
selectizeInput("indepVars", "+ Independent variables", choices = muVars, selected = defaultIndepVars, multiple = TRUE)

# Add a dropdown for selecting the correction method
selectizeInput("correctionMethod", "Correction Method", choices = c("bonferroni", "tukey", "holm"), selected = "bonferroni", multiple = FALSE)

# Add a text input for custom model formula
textInput("customModel", "Custom Model Formula: dependent_variable ~ ", value = "VFD * startedWithNoise + trialNum + (1 | participant)")

# Add a checkbox to use the custom model formula
checkboxInput("useCustomModel", "Use Custom Model Formula", value = FALSE)
```

Column
--------------------------------------------

### Statistics Results  {data-height=500}
```{r}
#plotOutput("qq") ## QQ plot to check if we can use LMM?
verbatimTextOutput("lmm_text")
```
### Tables

#### Fixed effects {data-height=500}
```{r}
tableOutput("fixed_effects_table")
```

#### Random effects {data-height=500}
```{r}
tableOutput("random_effects_table")
```

#### Post-hoc tests {data-height=500}
```{r}
tableOutput("post_hoc_table")
```

```{r, context="server"}
get_lmer <- reactive({
  dt <- get_mu_dyn_long()
  
  # Construct the formula dynamically using inputs
  dep_var <- input$depVar
  if (input$useCustomModel && input$customModel != "") {
    # Use custom model formula if checkbox is selected and text input is not empty
    formula_text <-  paste(dep_var, "~", input$customModel)
  } else {
    interVars <- paste(input$indepInterVars, collapse = "*")
    otherVars <- paste(input$indepVars, collapse = "+")
    finalVars <- paste(interVars, "+", otherVars)
    formula_text <- paste(dep_var, "~", finalVars, "+ (1 | participant)")
  }
  
  # Convert to formula
  formula <- as.formula(formula_text)
  
  # Fit the model
  return(lmerTest::lmer(formula, data = dt, REML = FALSE)) # put lmerTest:: in front to get p values.
})


output$lmm_text <- renderPrint({
  lmm <- get_lmer()
  results <- summary(lmm)
  
  # Summarize the model
  cat("\nLMM:\n")
  print(lmm)
  cat("\nRESULTS:\n")
  print(results)
})

set_digits <- function(df, digits = 4){
    # Format the numbers to display more digits
  df <- df %>%
    mutate(across(where(is.numeric), ~ format(round(.x, digits = digits), nsmall = digits)))
  return(df)
}

output$fixed_effects_table <- renderTable({
  lmm <- get_lmer()
  results <- summary(lmm)
  fixed_effects <- results$coefficients
  
  # Calculate effect sizes
  residual_sd <- sigma(lmm)
  fixed_effects_df <- as.data.frame(fixed_effects)
  fixed_effects_df$EffectSize <- fixed_effects_df$Estimate / residual_sd
  
  # Adjust p-values for multiple comparisons using the selected correction method
  correction_method <- input$correctionMethod
  fixed_effects_df$AdjustedP <- p.adjust(fixed_effects_df[["Pr(>|t|)"]], method = correction_method)
  
  # Convert to a data frame for rendering and include row names
  fixed_effects_df <- cbind(Effect = rownames(fixed_effects_df), fixed_effects_df)
  rownames(fixed_effects_df) <- NULL
  
  fixed_effects_df <- set_digits(fixed_effects_df)
  
  fixed_effects_df
}, rownames = TRUE)


output$random_effects_table <- renderTable({
  lmm <- get_lmer()
  random_effects <- as.data.frame(VarCorr(lmm))
  
  # Clean up the random effects table
  random_effects_df <- cbind(Effect = rownames(random_effects), random_effects)
  rownames(random_effects_df) <- NULL
  
  # Select only relevant columns
  random_effects_df <- random_effects_df[, c("Effect", "grp", "vcov", "sdcor")]
  
  # Optionally rename columns for clarity
  colnames(random_effects_df) <- c("Effect", "Group", "Variance", "Standard Deviation")
  
  random_effects_df <- set_digits(random_effects_df)
  
  random_effects_df
}, rownames = TRUE)

output$qq <- renderPlot({
  lmm <- get_lmer()
  p <- qqnorm(resid(lmm))
  return(p)
})

output$post_hoc_table <- renderTable({
  lmm <- get_lmer()
  results <- summary(lmm)
  
  # Extract fixed effects excluding the intercept
  fixed_effects <- results$coefficients
  effects_to_test <- rownames(fixed_effects)
  effects_to_test <- effects_to_test[effects_to_test != "(Intercept)"]
  #significant_effects <- rownames(results$coefficients)[results$coefficients[, "Pr(>|t|)"] < 0.05]
  #significant_effects <- significant_effects[significant_effects != "(Intercept)"]
  
  if (length(effects_to_test) > 0) {
    posthoc_results <- list()
    
    # Iterate through the independent variables selected
    for (indep_var in input$indepVars) {
      # Check each effect to see if it contains the independent variable (handle interactions)
      for (effect in effects_to_test) {
        # Perform post-hoc test for each level of the independent variable
        posthoc_test <- emmeans::emmeans(lmm, specs = indep_var)
        pairwise_comparisons <- emmeans::contrast(posthoc_test, method = "pairwise") # side = ">" --> check only one side
        #posthoc_results[[effect]] <- summary(posthoc_test)
        pairwise_results <- summary(pairwise_comparisons)
        posthoc_results[[effect]] <- pairwise_results
      }
    }
    
    # Combine posthoc results into a single data frame
    posthoc_df <- do.call(rbind, lapply(posthoc_results, function(x) as.data.frame(x)))
    posthoc_df <- cbind(Effect = rep(names(posthoc_results), sapply(posthoc_results, nrow)), posthoc_df)
    
    # Format the numbers to display more digits
    posthoc_df <- set_digits(posthoc_df)
    
    return(posthoc_df)
  } else {
    return(data.frame(Message = "No significant main or interaction effects found."))
  }
}, rownames = TRUE)

```
