### Options

```{r}
defaultIndepVars <- c("VFD")
defaultDepVar <- "stepWidths.sd"
selectizeInput("depVar", "Dependent variable", choices = muVars, selected = defaultDepVar, multiple = FALSE)
selectizeInput("indepInterVars", "* Independent variables", choices = muVars, selected = defaultIndepVars, multiple = TRUE)
selectizeInput("indepVars", "+ Independent variables", choices = muVars, selected = defaultIndepVars, multiple = TRUE)

# Add a dropdown for selecting the correction method
selectizeInput("correctionMethod", "Correction Method", choices = c("bonferroni", "tukey", "holm"), selected = "bonferroni", multiple = FALSE)

# Add a text input for custom model formula
textInput("customModel", "Custom Model Formula: dependent_variable ~ ", value = "stepWidths.sd ~ VFD * (startedWithNoise + VEQ.total) + trialNumWithinCondition + (1 | participant)")

# Add a checkbox to use the custom model formula
checkboxInput("useCustomModel", "Use Custom Model Formula", value = FALSE)
```

Column
--------------------------------------------

### Statistics Results  {data-height=500}
```{r}
verbatimTextOutput("lmm_text")
```
### Tables

#### Fixed effects {data-height=500}
```{r}
tableOutput("fixed_effects_table")
```

#### Random effects {data-height=500}
```{r}
tableOutput("random_effects_table")
```

#### Post-hoc tests {data-height=500}
```{r}
tableOutput("post_hoc_table")
```

### Check Assumptions
#### QQ Plot  {data-height=500}
- Interpret the Plot: The QQ plot compares the quantiles of the residuals from your model to the quantiles of a normal distribution. If the residuals are normally distributed, the points on the QQ plot will fall approximately along a straight line (the 45-degree reference line).
- Look for Deviations: Significant deviations from the straight line suggest departures from normality. Small deviations are expected and acceptable, but large deviations or patterns (such as curves or S-shaped patterns) indicate that the residuals are not normally distributed.
- Use QQ Line: The reference line (QQ line) helps in visualizing the deviation. The closer the points are to this line, the more normally distributed the residuals are.
```{r}
plotOutput("qq")
```
#### residuals_vs_fitted {data-height=1500}
Check for homoscedasticity and non-linearity. Look for a random scatter of residuals around zero.

```{r}
plotOutput("residuals_vs_fitted")
```
#### scale_location {data-height=500}
Check for homoscedasticity. Look for a horizontal line with equally spread points.

```{r}
plotOutput("scale_location")
```
#### residuals_vs_leverage {data-height=500}
Check for influential cases. Look for any points outside the Cook's distance lines.

```{r}
plotOutput("residuals_vs_leverage")
```

```{r, context="server"}
get_lmer <- reactive({
  dt <- get_mu_dyn_long()
  
  # Construct the formula dynamically using inputs
  dep_var <- input$depVar
  if (input$useCustomModel && input$customModel != "") {
    # Use custom model formula if checkbox is selected and text input is not empty
    #formula_text <-  paste(dep_var, "~", input$customModel)
    formula_text <- input$customModel
  } else {
    interVars <- paste(input$indepInterVars, collapse = "*")
    otherVars <- paste(input$indepVars, collapse = "+")
    finalVars <- paste(interVars, "+", otherVars)
    formula_text <- paste(dep_var, "~", finalVars, "+ (1 | participant)")
  }
  
  # Convert to formula
  formula <- as.formula(formula_text)
  
  # Fit the model
  return(lmerTest::lmer(formula, data = dt, REML = FALSE)) # put lmerTest:: in front to get p values.
})


output$lmm_text <- renderPrint({
  lmm <- get_lmer()
  results <- summary(lmm)
  
  # Summarize the model
  cat("\nLMM:\n")
  print(lmm)
  cat("\nRESULTS:\n")
  print(results)
  
  # Print AIC and BIC
  aic_value <- AIC(lmm)
  bic_value <- BIC(lmm)
  log_likelihood <- logLik(lmm)
  deviance <- deviance(lmm)
  r_squared <- MuMIn::r.squaredGLMM(lmm)
  
  cat("\nModel fit statistics:\n")
  cat("AIC:", aic_value, "\n")
  cat("BIC:", bic_value, "\n")
  cat("Log-likelihood:", log_likelihood, "\n")
  cat("Deviance:", deviance, "\n")
  cat("Marginal R-squared:", r_squared[1], "\n")
  cat("Conditional R-squared:", r_squared[2], "\n")
})

set_digits <- function(df, digits = 4){
    # Format the numbers to display more digits
  df <- df %>%
    mutate(across(where(is.numeric), ~ format(round(.x, digits = digits), nsmall = digits)))
  return(df)
}

output$fixed_effects_table <- renderTable({
  lmm <- get_lmer()
  results <- summary(lmm)
  fixed_effects <- results$coefficients
  
  # Calculate effect sizes
  residual_sd <- sigma(lmm)
  fixed_effects_df <- as.data.frame(fixed_effects)
  fixed_effects_df$EffectSize <- fixed_effects_df$Estimate / residual_sd
  
  # Adjust p-values for multiple comparisons using the selected correction method
  correction_method <- input$correctionMethod
  fixed_effects_df$AdjustedP <- p.adjust(fixed_effects_df[["Pr(>|t|)"]], method = correction_method)
  
  # Convert to a data frame for rendering and include row names
  fixed_effects_df <- cbind(Effect = rownames(fixed_effects_df), fixed_effects_df)
  rownames(fixed_effects_df) <- NULL
  
  fixed_effects_df <- set_digits(fixed_effects_df)
  
  fixed_effects_df
}, rownames = TRUE)


output$random_effects_table <- renderTable({
  lmm <- get_lmer()
  random_effects <- as.data.frame(VarCorr(lmm))
  
  # Clean up the random effects table
  random_effects_df <- cbind(Effect = rownames(random_effects), random_effects)
  rownames(random_effects_df) <- NULL
  
  # Select only relevant columns
  random_effects_df <- random_effects_df[, c("Effect", "grp", "vcov", "sdcor")]
  
  # Optionally rename columns for clarity
  colnames(random_effects_df) <- c("Effect", "Group", "Variance", "Standard Deviation")
  
  random_effects_df <- set_digits(random_effects_df)
  
  random_effects_df
}, rownames = TRUE)

output$post_hoc_table <- renderTable({
  lmm <- get_lmer()
  results <- summary(lmm)
  
  # Extract significant fixed effects (excluding intercept)
  fixed_effects <- results$coefficients
  #effects_to_test <- rownames(fixed_effects)
  #effects_to_test <- effects_to_test[effects_to_test != "(Intercept)"]
  significant_effects <- rownames(results$coefficients)[results$coefficients[, "Pr(>|t|)"] < 0.05]
  significant_effects <- significant_effects[significant_effects != "(Intercept)"]
  effects_to_test <- significant_effects
  
  # Function to clean variable names by removing trailing levels (e.g., TRUE, FALSE, numeric values)
  clean_effect_name <- function(effect_name) {
    # Remove trailing TRUE, FALSE, or numbers from variable names
    cleaned_name <- gsub("(TRUE|FALSE|[0-9.]+)$", "", effect_name)
    return(cleaned_name)
  }
  
  # Initialize post-hoc results list
  posthoc_results <- list()
  
  # Iterate through the independent variables selected (categorical variables for post-hoc tests)
  for (indep_var in effects_to_test) {
    if (grepl(":", indep_var)) {
      # Interaction term detected, perform post-hoc test for interaction
      interaction_vars <- clean_effect_name(unlist(strsplit(indep_var, ":")))
      posthoc_test <- emmeans::emmeans(lmm, specs = interaction_vars)
    } else {
      # Perform post-hoc test for the main effect
      posthoc_test <- emmeans::emmeans(lmm, specs = clean_effect_name(indep_var))
    }
    pairwise_comparisons <- emmeans::contrast(posthoc_test, method = "pairwise")
    
    # Store results for this independent variable
    pairwise_results <- summary(pairwise_comparisons)
    posthoc_results[[indep_var]] <- pairwise_results
  }
  
  # Combine posthoc results into a single data frame
  if (length(posthoc_results) > 0) {
    posthoc_df <- do.call(rbind, lapply(posthoc_results, as.data.frame))
    posthoc_df <- cbind(Effect = rep(names(posthoc_results), sapply(posthoc_results, nrow)), posthoc_df)
    
    # Format the numbers to display more digits
    posthoc_df <- set_digits(posthoc_df)
    
    return(posthoc_df)
  } else {
    return(data.frame(Message = "No significant main or interaction effects found."))
  }
}, rownames = TRUE)


output$qq <- renderPlot({
  lmm <- get_lmer()
  qqnorm(resid(lmm))
  qqline(resid(lmm))
}, height = reactive(input$plotheight))

output$residuals_vs_fitted <- renderPlot({
  lmm <- get_lmer()
  plot(fitted(lmm), resid(lmm), 
       xlab = "Fitted values", 
       ylab = "Residuals",
       main = "Residuals vs Fitted")
  abline(h = 0, col = "red")
}, height = reactive(input$plotheight))

output$scale_location <- renderPlot({
  lmm <- get_lmer()
  sqrt_resid <- sqrt(abs(resid(lmm)))
  plot(fitted(lmm), sqrt_resid,
       xlab = "Fitted values",
       ylab = "Square root of standardized residuals",
       main = "Scale-Location Plot")
  abline(h = 0, col = "red")
}, height = reactive(input$plotheight))

output$residuals_vs_leverage <- renderPlot({
  lmm <- get_lmer()
  leverage <- hatvalues(lmm)
  cooksd <- cooks.distance(lmm)
  plot(leverage, resid(lmm),
       xlab = "Leverage",
       ylab = "Residuals",
       main = "Residuals vs Leverage Plot")
  abline(h = 0, col = "red")
  points(leverage, resid(lmm), pch = 20, col = ifelse(cooksd > 4/(nrow(leverage) - length(coef(lmm))), "red", "black"))
  # Add Cook's distance lines
  cooksd_line <- 4/(nrow(leverage) - length(coef(lmm)))
  abline(v = cooksd_line, col = "blue", lty = 2)
  abline(v = 2 * cooksd_line, col = "blue", lty = 2)
})

```
