### Plot Options
```{r}
numericInput("rotationCorrectionX", "Rotation Correction X (degrees)",
  min = -360, max = 360, value = 0, step = 0.1)
numericInput("rotationCorrectionY", "Rotation Correction Y (degrees)",
  min = -360, max = 360, value = 0, step = 0.1)
numericInput("rotationCorrectionZ", "Rotation Correction Z (degrees)",
  min = -360, max = 360, value = 0, step = 0.1)

# Add save rotation button
actionButton("saveRotation", "Save Rotation")

# Add export to CSV button
downloadButton("exportRotations", "Export Rotations to CSV")

# Add import from CSV button
fileInput("importRotations", "Import Rotations from CSV",
  accept = c("text/csv", "text/comma-separated-values,text/plain", ".csv"))

checkboxInput("filter_15", "Show filtered data",
  value = FALSE)
selectizeInput("participant_15", "participant",
  choices = participants, selected = participants[1], multiple = FALSE)
selectizeInput("trialNum_15", "Trial Number",
  choices = trials, selected = trials[2], multiple = FALSE) # set to trial 2 so that if practice is filtered out, it still plots

selectizeInput("xplot_15", "xplot",
  choices = xOptions, selected = "time", multiple = FALSE)
selectizeInput("yplot_15", "yplot",
  choices = xOptions, selected = "pos.x", multiple = FALSE)

# Add x and y limits inputs
numericInput("xlim_min_15", "X-axis minimum",
  min = -Inf, max = Inf, value = NA, step = 0.1)
numericInput("xlim_max_15", "X-axis maximum",
  min = -Inf, max = Inf, value = NA, step = 0.1)
numericInput("ylim_min_15", "Y-axis minimum",
  min = -Inf, max = Inf, value = NA, step = 0.1)
numericInput("ylim_max_15", "Y-axis maximum",
  min = -Inf, max = Inf, value = NA, step = 0.1)
```

Column
--------------------------------------------
### Transformed Feet Trajectories {data-height=1500}
Save rotations dataset under "./data_modifications/rotations_kinematic_data.csv". If there already is a dataset here, remove it and restart the code before making any adjustments here (otherwise you are adjusting a already adjusted dataset).
```{r}
plotlyOutput("FeetTraj_15", width = "100%", height = "100%")
```

### Rotation Corrections Table
```{r}
tableOutput("rotationTable")
```

```{r, context="server"}
# Initialize rotation dataframe
rotationDF <- reactiveVal(data.frame(participant = character(),
                                     trial = numeric(),
                                     rotation_x = numeric(),
                                     rotation_y = numeric(),
                                     rotation_z = numeric(),
                                     stringsAsFactors = FALSE))

# Function to get or set rotation
getRotation <- function(participant, trial) {
  df <- rotationDF()
  row <- df[df$participant == participant & df$trial == trial, ]
  if (nrow(row) > 0) {
    return(c(row$rotation_x, row$rotation_y, row$rotation_z))
  }
  # If not found, look for any rotation for the same participant
  participantRow <- df[df$participant == participant, ]
  if (nrow(participantRow) > 0) {
    return(c(participantRow$rotation_x[1], participantRow$rotation_y[1], participantRow$rotation_z[1]))
  }
  return(c(0, 0, 0))  # Default to 0 if no rotation found
}

# Update rotation input when participant or trial changes
observe({
  rotations <- getRotation(input$participant_15, as.numeric(input$trialNum_15))
  updateNumericInput(session, "rotationCorrectionX", value = rotations[1])
  updateNumericInput(session, "rotationCorrectionY", value = rotations[2])
  updateNumericInput(session, "rotationCorrectionZ", value = rotations[3])
})

# Save rotation when button is clicked
observeEvent(input$saveRotation, {
  df <- rotationDF()
  participant <- input$participant_15
  trial <- as.numeric(input$trialNum_15)
  rotation_x <- input$rotationCorrectionX
  rotation_y <- input$rotationCorrectionY
  rotation_z <- input$rotationCorrectionZ
  
  # Update or add new row
  if (nrow(df[df$participant == participant & df$trial == trial, ]) > 0) {
    df[df$participant == participant & df$trial == trial, c("rotation_x", "rotation_y", "rotation_z")] <- c(rotation_x, rotation_y, rotation_z)
  } else {
    df <- rbind(df, data.frame(participant = participant, trial = trial, rotation_x = rotation_x, rotation_y = rotation_y, rotation_z = rotation_z))
  }
  
  rotationDF(df)
})

# Export rotations to CSV
output$exportRotations <- downloadHandler(
  filename = function() {
    paste("rotations-", Sys.Date(), ".csv", sep="")
  },
  content = function(file) {
    write.csv(rotationDF(), file, row.names = FALSE)
  }
)

# Import rotations from CSV
observeEvent(input$importRotations, {
  req(input$importRotations)
  tryCatch(
    {
      df <- read.csv(input$importRotations$datapath, stringsAsFactors = FALSE)
      if (all(c("participant", "trial", "rotation_x", "rotation_y", "rotation_z") %in% colnames(df))) {
        rotationDF(df)
        showNotification("Rotations imported successfully", type = "message")
      } else {
        showNotification("Invalid CSV format. Please ensure the file has 'participant', 'trial', 'rotation_x', 'rotation_y', and 'rotation_z' columns.", type = "error")
      }
    },
    error = function(e) {
      showNotification(paste("Error importing rotations:", e$message), type = "error")
    }
  )
})

# Render rotation table
output$rotationTable <- renderTable({
  rotationDF()
})

output$FeetTraj_15 <- renderPlotly({
  tnum <- as.numeric(input$trialNum_15)
  preprocessedData <- preprocess_data(input$participant_15, tnum) 
  rotation <- getRotation(input$participant_15, tnum)
  
  # Define the axes order
  axes <- c("x", "y", "z")
  
  # Rotate the preprocessed data using the rotation vector and axes
  preprocessedData <- rotate_preprocessed_data(preprocessedData, rotation, axes = axes)

  # Create the base ggplot
  p <- plot_steps(
    filteredParams(), input$participant_15, tnum,
    input$xplot_15, input$yplot_15, input$filter_15, 
    baseSize = input$baseSize,
    xlim = c(input$xlim_min_15, input$xlim_max_15),
    ylim = c(input$ylim_min_15, input$ylim_max_15),
    preprocessedData = preprocessedData
  )
  
  # Convert to ggplotly
  ggplotly(p, width = input$plotwidth, height = input$plotheight) %>%
    layout(autosize = F)
})
```