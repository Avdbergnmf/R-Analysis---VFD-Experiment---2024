### Actions

```{r}
selectizeInput("participant", "participant",
  choices = participants, selected = participants[1], multiple = FALSE)
selectizeInput("trialNum", "Trial Number",
  choices = trialNumbers, selected = trialNumbers[2], multiple = FALSE) # set to trial 2 so that if practice is filtered out, it still plots
selectizeInput("xplot_15", "xplot",
  choices = xOptions, selected = "time", multiple = FALSE)#xOptions[2]
selectizeInput("yplot_15", "yplot",
  choices = xOptions, selected = "pos_x", multiple = FALSE) #xOptions[3]

# Add x and y limits inputs
numericInput("xlim_min_15", "X-axis minimum",
  min = -Inf, max = Inf, value = 0, step = 0.1)
numericInput("xlim_max_15", "X-axis maximum",
  min = -Inf, max = Inf, value = 20, step = 0.1)
numericInput("ylim_min_15", "Y-axis minimum",
  min = -Inf, max = Inf, value = -.5, step = 0.1)
numericInput("ylim_max_15", "Y-axis maximum",
  min = -Inf, max = Inf, value = .5, step = 0.1)

fileInput("importOutliers", "Import Outliers from CSV",
  accept = c("text/csv", "text/comma-separated-values,text/plain", ".csv"))
downloadButton("export_outliers", "Export Outliers to CSV")
actionButton("overwrite_outliers", "Overwrite Outliers")
```

Column
--------------------------------------------
### Foot Trajectories {data-width=650 data-height=1500}
Mostly look at the heelstrikes. These are used for step calculation.
```{r}
plotlyOutput("manualOutlierPlot")
```

Column
--------------------------------------------
### Selected Outliers  {data-width=350 data-height=1500}

```{r}
DT::dataTableOutput("selectedOutliersTable")
```

```{r, context="server"}
observeEvent(input$importOutliers, {
  req(input$importOutliers)
  tryCatch(
    {
      df <- read.csv(input$importOutliers$datapath, stringsAsFactors = FALSE)
      if (all(c("participant", "trialNum", "heelStrikes.time") %in% colnames(df))) {
        # Convert trialNum to numeric if it's not already
        df$trialNum <- as.numeric(df$trialNum)
        # Update the selected_outliers reactive value
        selected_outliers(df)
        showNotification("Outliers imported successfully", type = "message")
      } else {
        showNotification("Invalid CSV format. Please ensure the file has 'participant', 'trialNum', and 'heelStrikes.time' columns.", type = "error")
      }
    },
    error = function(e) {
      showNotification(paste("Error importing outliers:", e$message), type = "error")
    }
  )
})

# Reactive value to store selected outliers
selected_outliers <- reactiveVal(data.frame(
  participant = character(),
  trialNum = numeric(),
  heelStrikes.time = numeric(),
  stringsAsFactors = FALSE
))

# Render the interactive plot
output$manualOutlierPlot <- renderPlotly({
  req(filteredParams())
  
  # Get the current participant and trial from the sidebar inputs
  current_participant <- input$participant
  current_trial <- as.numeric(input$trialNum)
  
  # Create the base ggplot
  p <- plot_steps(
    filteredParams(), current_participant, current_trial,
    input$xplot_15, input$yplot_15, input$filter, 
    baseSize = input$baseSize
  )
  # 
  # Convert to plotly, ensuring only `geom_point` layers are selectable
  p <- ggplotly(p,width = input$plotwidth, height = input$plotheight) %>%
    style(
      hoverinfo = "none", # Disable hover info on paths if not needed
      traces = which(sapply(.$x$data, function(d) d$type) == "scatter" & sapply(.$x$data, function(d) d$mode) == "lines")
    ) %>%
    layout(dragmode = "pan",
      xaxis = list(range = c(input$xlim_min_15, input$xlim_max_15)),
      yaxis = list(range = c(input$ylim_min_15, input$ylim_max_15))
    ) %>%
    event_register("plotly_click")
  return(p)
})

# Update selected outliers based on plot clicks
observeEvent(event_data("plotly_click"), {
  click_data <- event_data("plotly_click")
  
  if (!is.null(click_data)) {
    current_participant <- input$participant
    current_trial <- as.numeric(input$trialNum)
    clicked_time <- click_data$x
    
    # Find the closest heel strike in filteredParams()
    params <- filteredParams()
    closest_step <- params[params$participant == current_participant &
                           params$trialNum == current_trial, ] %>%
      mutate(time_diff = abs(heelStrikes.time - clicked_time)) %>%
      arrange(time_diff) %>%
      slice(1)
    
    if (nrow(closest_step) > 0 && closest_step$time_diff <= 0.25) {
      new_outlier <- data.frame(
        participant = closest_step$participant,
        trialNum = closest_step$trialNum,
        heelStrikes.time = closest_step$heelStrikes.time,
        stringsAsFactors = FALSE
      )
      
      current_outliers <- selected_outliers()
      updated_outliers <- rbind(current_outliers, new_outlier)
      updated_outliers <- unique(updated_outliers)
      selected_outliers(updated_outliers)

      showNotification("Outlier added", type = "message")
    }
  }
})

# Render the selected outliers table
output$selectedOutliersTable <- DT::renderDataTable({
  DT::datatable(
    selected_outliers()
    #options = list(pageLength = 10),
    #selection = 'single'
  )
})

# Remove selected outlier when clicked in the table
observeEvent(input$selectedOutliersTable_rows_selected, {
  selected_row <- input$selectedOutliersTable_rows_selected
  if (!is.null(selected_row)) {
    current_outliers <- selected_outliers()
    updated_outliers <- current_outliers[-selected_row, ]
    selected_outliers(updated_outliers)
    showNotification("Outlier removed", type = "message")
  }
})

# Export rotations to CSV
output$export_outliers <- downloadHandler(
  filename = function() {
    paste("outliers-", Sys.Date(), ".csv", sep="")
  },
  content = function(file) {
    write.csv(selected_outliers(), file, row.names = FALSE)
  }
)

# Observer to overwrite outliers in allGaitParams
observeEvent(input$overwrite_outliers, {
  outliers_data <- selected_outliers()
  
  # Reset all outlier steps to FALSE
  allGaitParams$heelStrikes.outlierSteps <<- FALSE
  
  # Mark steps as outliers if they match the selected outliers
  for (i in seq_len(nrow(outliers_data))) {
    match_indices <- which(
      allGaitParams$participant == outliers_data$participant[i] &
      allGaitParams$trialNum == outliers_data$trialNum[i] &
      abs(allGaitParams$heelStrikes.time - outliers_data$heelStrikes.time[i]) <= 0.01
    )
    
    if (length(match_indices) > 0) {
      # Take the first match if multiple are found within the time range
      allGaitParams$heelStrikes.outlierSteps[match_indices[1]] <<- TRUE
      # Take all matches
      #allGaitParams$heelStrikes.outlierSteps[match_indices] <<- TRUE
    }
  }
  
  # Increment the trigger to force an update of filteredGaitParams
  refresh_trigger(refresh_trigger() + 1)
  
  showNotification("Outliers overwritten", type = "message")
})
```