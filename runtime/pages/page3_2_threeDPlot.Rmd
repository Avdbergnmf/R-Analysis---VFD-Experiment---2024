### Plot Options
```{r}
checkboxInput("plotlines", "Plot lines", value = TRUE)
checkboxInput("plotpoints", "Plot points", value = FALSE)

selectizeInput("participant3d", "Participant",
  choices = participants, selected = participants[1], multiple = FALSE)
selectizeInput("trialNum3d", "Trial Number",
  choices = trialNumbers, selected = trialNumbers[1], multiple = FALSE)

numericInput("startTime", "Start time (s)",
  min = 0, max = 500, value = 0, step = 1)
numericInput("endTime", "End time (s)",
  min = 0, max = 500, value = 0, step = 1)

numericInput("maxv", "Max velocity for filtering",
  min = 0, max = 1000, value = 100, step = 1)
numericInput("nPasses", "Number of filter passes",
  min = 1, max = 10, value = 1, step = 1)

# Add a download button for the plot
downloadButton("download3dPlot", "Download Plot")
```

Column
--------------------------------------------
### 3D plot {data-height=1500}

```{r}
rglwidgetOutput("ThreeD", width = "100%", height = "800px")
```

```{r, context="server"}
tf_gizmo <- function(origin, len, rotationMatrix = diag(4), label = "", labelaxes = TRUE, labelsize = 0.6){
  rotationMatrix <- rotationMatrix[1:3,1:3] # we only use the rotation
  xAxis <- as.vector(rotationMatrix %*% c(len, 0, 0))
  yAxis <- as.vector(rotationMatrix %*% c(0, len, 0))
  zAxis <- as.vector(rotationMatrix %*% c(0, 0, len))
  arrow3d(origin, origin + xAxis, col="red")   # X-axis
  arrow3d(origin, origin + yAxis, col="green") # Y-axis
  arrow3d(origin, origin + zAxis, col="blue")  # Z-axis
  
  text3d(origin, text = label, col = "white", adj = c(0, 0), cex = labelsize)
  
  # Label the axes
  if (labelaxes) {
    text3d(origin + xAxis, text = "X", col = "red", adj = c(0, 0), cex = 0.5*labelsize)
    text3d(origin + yAxis, text = "Y", col = "green", adj = c(0, 0), cex = 0.5*labelsize)
    text3d(origin + zAxis, text = "Z", col = "blue", adj = c(0, 0), cex = 0.5*labelsize)
  }
}

draw_mean_axes <- function(data, trackerName, label, labelsize = 0.6){
  posCols <- grep(paste0(trackerName,"\\.pos"), colnames(data), value = TRUE)
  rotCols <- grep(paste0(trackerName,"\\.rot"), colnames(data), value = TRUE)
  
  # Calculate the means (First 1000 datapoints should suffice, is just for plot)
  meanPos <- sapply(data[1:1000, posCols], mean, na.rm = TRUE)
  meanQuaternion <- sapply(data[1:1000, rotCols], mean, na.rm = TRUE) # this should be done with slerp but for now this is fine.
  
  points3d(meanPos[1], meanPos[2], meanPos[3], col = "red", size = 5)
  tf_gizmo(meanPos, 0.1, quaternionToRotationMatrix(meanQuaternion), label, labelsize)
}

output$ThreeD <- renderRglwidget({
  # Clear existing rgl plot
  clear3d()
  # Set uniform aspect ratio
  rgl::aspect3d(1, 1, 1)
  # Get data
  data <- preprocess_data(input$participant3d, as.numeric(input$trialNum3d))
  data <- filter_all_data(data, input$maxv, input$nPasses)
  
  # Subset data based on start and end times
  data <- subset(data, time >= input$startTime & time <= input$endTime)
  
  # add axes
  axes3d()
  axis3d('y', pos = c(0, 0, 0))
  
  # Plot transformation data
  # Add origin arrows
  tf_gizmo(c(0,0,0), 0.2)
  origin <- -tmatrix[1:3, 4]
  arrow3d(origin, origin + 0.3*tmatrix[1:3, 1], col="red")   # X-axis
  arrow3d(origin, origin + 0.3*tmatrix[1:3, 2], col="green") # Y-axis
  arrow3d(origin, origin + 0.3*tmatrix[1:3, 3], col="blue")  # Z-axis
  
  # Create your 3D plot
  leftFootCols <- grep("LeftFoot.pos", colnames(data), value = TRUE)
  rightFootCols <- grep("RightFoot.pos", colnames(data), value = TRUE)
  
  if (input$plotlines) {
    lines3d(data[[leftFootCols[1]]], data[[leftFootCols[2]]], data[[leftFootCols[3]]], color="blue") 
    lines3d(data[[rightFootCols[1]]], data[[rightFootCols[2]]], data[[rightFootCols[3]]], color="red") 
  }
  
  if (input$plotpoints) {
    points3d(data[[leftFootCols[1]]], data[[leftFootCols[2]]], data[[leftFootCols[3]]], color="blue", size=2)
    points3d(data[[rightFootCols[1]]], data[[rightFootCols[2]]], data[[rightFootCols[3]]], color="red", size=2)
  }
  
  draw_mean_axes(data, "TreadmillLeft", "L", 1)
  draw_mean_axes(data, "TreadmillRight", "R", 1)
  
  # Return the rgl widget
  rglwidget()
})

# Add a download handler for the plot
output$download3dPlot <- downloadHandler(
  filename = function() {
    paste("3D_plot", Sys.Date(), ".png", sep = "")
  },
  content = function(file) {
    # Capture the current 3D plot
    rgl.snapshot(file, fmt = "png")
  }
)
```